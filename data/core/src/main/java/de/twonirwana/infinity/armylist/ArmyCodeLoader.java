package de.twonirwana.infinity.armylist;

import com.google.common.annotations.VisibleForTesting;
import de.twonirwana.infinity.ArmyList;
import de.twonirwana.infinity.Sectorial;
import de.twonirwana.infinity.db.DataLoader;
import de.twonirwana.infinity.unit.api.UnitOption;
import lombok.extern.slf4j.Slf4j;

import java.net.URLDecoder;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * # Army Codes
 * These are the shorthand codes generated by Army builder representing an army. They are base64 encoded strings.
 * <p>
 * ## Numbers
 * Integers are stored using a form of variable length encoding. If the value is under 128, then it is stored in a byte normally.
 * For larger numbers, two bytes are used and the first bit of the first byte is set high to flag this.
 * Should a larger number still be required, then presumably it would go up to 6 bytes, but no number in the game gets remotely that high.
 * <p>
 * ## Strings
 * Strings are encoded in the form `length, text`. and are not null terminated. 0 is a valid value for string length (in which case the text part will be absent).
 * <p>
 * ## Code Structure.
 * The code can be broken down into two parts - the header and the combat groups.
 * <p>
 * ### Header
 * The header is laid out as follows:
 * ````
 * ID of sectorial (int)
 * Name of sectorial (string)
 * Name of the army (string) - defaults to ' '
 * Point _limit_ used (int)
 * Number of combat groups (int)
 * ````
 * <p>
 * ### Combat Groups
 * Each combat group is as follows:
 * ````
 * 10
 * combat group number (int)
 * number of members of the group (int)
 * combat group member (see below) x number of members
 * ````
 * <p>
 * #### Combat Group Members
 * Each of these corresponds to a line in the army list in army builder.
 * ```
 * 00 (an empty byte)
 * Unit ID (int)
 * Group choice (int)
 * Option choice (int)
 * 00 (an empty byte)
 * ```
 */

@Slf4j
public class ArmyCodeLoader {

    private static int readVLI(ByteBuffer data) {
        data.mark();
        int result = data.get();
        if (result < 0) {
            data.reset();
            result = data.getShort() & 0xffff & ~(1 << 15L);
        }
        return result;
    }


    public static ArmyList fromArmyCode(final String armyCode, DataLoader dataLoader) throws IllegalArgumentException {
        ArmyCodeData armyCodeData;
        try {
            armyCodeData = mapArmyCode(armyCode);
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
        Sectorial sectorial = dataLoader.getSectorialIdMap().get(armyCodeData.sectorialId);
        List<UnitOption> unitOptionList = dataLoader.getAllUnitsForSectorial(sectorial);

        Sectorial sectorialApiId = dataLoader.getAllSectorialIds().stream()
                .filter(s -> s.getId() == armyCodeData.sectorialId)
                .findFirst().orElseThrow(() -> new IllegalArgumentException("Could not find sectorial with id %d for %s".formatted(armyCodeData.sectorialId, armyCode)));
        Map<Integer, List<UnitOption>> combatGroups = armyCodeData.combatGroups.entrySet().stream()
                .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().stream()
                        .flatMap(m -> findUnitOptions(m, unitOptionList).stream())
                        .toList()));
        return new ArmyList(sectorialApiId, armyCodeData.sectorialName, armyCodeData.armyName, armyCodeData.maxPoints, combatGroups);
    }

    public static List<String> missingUnitsInArmyCode(final String armyCode, DataLoader dataLoader) throws IllegalArgumentException {
        ArmyCodeData armyCodeData;
        try {
            armyCodeData = mapArmyCode(armyCode);
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }

        Sectorial sectorial = dataLoader.getSectorialIdMap().get(armyCodeData.sectorialId);
        List<UnitOption> unitsForSectorial = dataLoader.getAllUnitsForSectorial(sectorial);
        List<UnitOption> allUnits = dataLoader.getAllUnits();

        return armyCodeData.combatGroups.values().stream()
                .flatMap(Collection::stream)
                .filter(m -> findUnitOptions(m, unitsForSectorial).size() != 1)
                .map(c -> {
                    Optional<String> unitName = allUnits.stream()
                            .filter(u -> u.getUnitId() == c.unitId())
                            .map(UnitOption::getUnitName)
                            .findFirst();
                    return unitName
                            .map(s -> "SectorialId: %d, UnitId: %d, GroupId: %d, OptionId: %d -> Unknown version of %s".formatted(armyCodeData.sectorialId, c.unitId(), c.groupId(), c.optionId(), s))
                            .orElseGet(() -> "SectorialId: %d, UnitId: %d, GroupId: %d, OptionId: %d".formatted(armyCodeData.sectorialId, c.unitId(), c.groupId(), c.optionId()));
                })
                .toList();
    }

    private static List<UnitOption> findUnitOptions(CombatGroupMember combatGroupMember, List<UnitOption> unitOptionList) {
        return unitOptionList.stream()
                .filter(uo -> uo.getUnitId() == combatGroupMember.unitId()
                        && uo.getGroupId() == combatGroupMember.groupId()
                        && uo.getOptionId() == combatGroupMember.optionId)
                .toList();
    }

    private static CombatGroupMember getCombatGroupMemberFromCode(ByteBuffer data) {
        CombatGroupMember result;
        final int unitId = readVLI(data);
        final int groupId = readVLI(data);
        final int optionId = readVLI(data);
        int zero = data.get(); //always 0

        result = new CombatGroupMember(
                unitId,
                groupId,
                optionId
        );
        return result;
    }

    private static List<CombatGroupMember> getCombatGroupFromCode(ByteBuffer data) {

        /*
        for debugging
        List<Integer> number = new ArrayList<>();
        int p = data.position();
        while (data.hasRemaining()) {
            number.add(readVLI(data));
        }
        data.position(p);
        log.info(number.toString());
        */

        int combatGroupId = readVLI(data);
        int versionSwitch = readVLI(data);
        Integer reinforcement = null; //reinforcement ?0 no, 1 yes
        if (versionSwitch == 1) {
            reinforcement = readVLI(data);
        }
        int combatGroupSize = readVLI(data);
        Integer fillerZero = null; //no use?
        if (versionSwitch == 1) {
            fillerZero = readVLI(data);
        }

        List<CombatGroupMember> result = new ArrayList<>();
        for (int i = 0; i < combatGroupSize; i++) {
            if (versionSwitch == 0) {
                int unitCount = readVLI(data);
            }
            result.add(getCombatGroupMemberFromCode(data));
            if (i < combatGroupSize - 1 && versionSwitch == 1) { //only for version 1
                int inBetweenMemberZero = readVLI(data); //always 0
            }
        }

        return result;
    }

    private static byte[] decodeArmyCode(String armyCode) {
        // Sometimes CB urlencodes the army code and sometimes it doesn't.
        try {
            return Base64.getDecoder().decode(armyCode);
        } catch (IllegalArgumentException exception) {
            try {
                String decoded = URLDecoder.decode(armyCode, StandardCharsets.UTF_8);
                return Base64.getDecoder().decode(decoded);
            } catch (Throwable t) {
                log.warn("Failed to decode army code: {} -> {}", armyCode, t.getMessage());
            }
        }
        return null;
    }

    @VisibleForTesting
    public static ArmyCodeData mapArmyCode(final String armyCode) {
        byte[] decoded = decodeArmyCode(armyCode);
        if (decoded == null) {
            throw new IllegalArgumentException("armyCode cannot be null");
        }

        ByteBuffer dataBuffer = ByteBuffer.wrap(decoded);

        int sectorialId = readVLI(dataBuffer);
        int faction_length = readVLI(dataBuffer);
        byte[] factionNameData = new byte[faction_length];
        dataBuffer.get(factionNameData, 0, faction_length);

        String fractionName = new String(factionNameData, StandardCharsets.UTF_8);

        // Get the army name, if set. The default army name is ' '.
        int armyNameLength = dataBuffer.get() & 0xffffff;
        String armyName = null;
        if (armyNameLength > 0) {
            byte[] army_name_data = new byte[armyNameLength];
            dataBuffer.get(army_name_data, 0, armyNameLength);
            armyName = new String(army_name_data, StandardCharsets.UTF_8);
        }

        int maxPoints = readVLI(dataBuffer);

        int combatGroupCount = readVLI(dataBuffer);
        Map<Integer, List<CombatGroupMember>> combatGroups = IntStream.range(0, combatGroupCount)
                .boxed()
                .collect(Collectors.toMap(i -> i + 1, i -> getCombatGroupFromCode(dataBuffer)));
        return new ArmyCodeData(sectorialId, fractionName, armyName, maxPoints, combatGroups);
    }

    public record CombatGroupMember(
            int unitId,
            int groupId,
            int optionId) {
        @Override
        public String toString() {
            return "%d-%d-%d".formatted(unitId, groupId, optionId);
        }
    }

    public record ArmyCodeData(
            int sectorialId,
            String sectorialName,
            String armyName,
            int maxPoints,
            Map<Integer, List<CombatGroupMember>> combatGroups) {
    }

}
