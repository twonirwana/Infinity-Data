package de.twonirwana.infinity.armylist;

import de.twonirwana.infinity.ArmyList;
import de.twonirwana.infinity.Sectorial;
import de.twonirwana.infinity.db.DataLoader;
import de.twonirwana.infinity.unit.api.UnitOption;

import java.net.URLDecoder;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * # Army Codes
 * These are the shorthand codes generated by Army builder representing an army. They are base64 encoded strings.
 * <p>
 * ## Numbers
 * Integers are stored using a form of variable length encoding. If the value is under 128, then it is stored in a byte normally.
 * For larger numbers, two bytes are used and the first bit of the first byte is set high to flag this.
 * Should a larger number still be required, then presumably it would go up to 6 bytes, but no number in the game gets remotely that high.
 * <p>
 * ## Strings
 * Strings are encoded in the form `length, text`. and are not null terminated. 0 is a valid value for string length (in which case the text part will be absent).
 * <p>
 * ## Code Structure.
 * The code can be broken down into two parts - the header and the combat groups.
 * <p>
 * ### Header
 * The header is laid out as follows:
 * ````
 * ID of sectorial (int)
 * Name of sectorial (string)
 * Name of the army (string) - defaults to ' '
 * Point _limit_ used (int)
 * Number of combat groups (int)
 * ````
 * <p>
 * ### Combat Groups
 * Each combat group is as follows:
 * ````
 * 10
 * combat group number (int)
 * number of members of the group (int)
 * combat group member (see below) x number of members
 * ````
 * <p>
 * #### Combat Group Members
 * Each of these corresponds to a line in the army list in army builder.
 * ```
 * 00 (an empty byte)
 * Unit ID (int)
 * Group choice (int)
 * Option choice (int)
 * 00 (an empty byte)
 * ```
 */

public class ArmyCodeLoader {

    private static int readVLI(ByteBuffer data) {
        data.mark();
        int result = data.get();
        if (result < 0) {
            data.reset();
            result = data.getShort() & 0xffff & ~(1 << 15L);
        }
        return result;
    }


    public static ArmyList fromArmyCode(final String armyCode, DataLoader dataLoader) throws IllegalArgumentException {
        byte[] data;

        // Sometimes CB urlencodes the army code and sometimes it doesn't.
        try {
            data = Base64.getDecoder().decode(armyCode);
        } catch (IllegalArgumentException exception) {
            try {
                String decoded = URLDecoder.decode(armyCode, StandardCharsets.UTF_8);
                data = Base64.getDecoder().decode(decoded);
            } catch (Throwable t) {
                throw new IllegalArgumentException("Failed to decode army code: " + armyCode, t);
            }
        }

        ByteBuffer dataBuffer = ByteBuffer.wrap(data);

        int sectorialId = readVLI(dataBuffer);
        Sectorial sectorial = dataLoader.getSectorialIdMap().get(sectorialId);
        int faction_length = readVLI(dataBuffer);
        byte[] factionNameData = new byte[faction_length];
        dataBuffer.get(factionNameData, 0, faction_length);

        String fractionName = new String(factionNameData, StandardCharsets.UTF_8);

        // Get the army name, if set. The default army name is ' '.
        int armyNameLength = dataBuffer.get() & 0xffffff;
        String armyName = null;
        if (armyNameLength > 0) {
            byte[] army_name_data = new byte[armyNameLength];
            dataBuffer.get(army_name_data, 0, armyNameLength);
            armyName = new String(army_name_data, StandardCharsets.UTF_8);
        }

        int maxPoints = readVLI(dataBuffer);

        int combatGroupCount = readVLI(dataBuffer);
        List<UnitOption> unitOptionList = dataLoader.getAllUnitsForSectorial(sectorial);
        Map<Integer, List<UnitOption>> combatGroups = IntStream.range(0, combatGroupCount)
                .boxed()
                .collect(Collectors.toMap(i -> i + 1, i -> {
                    List<CombatGroupMember> members = getCombatGroupFromCode(dataBuffer);
                    return members.stream()
                            .map(m -> unitOptionList.stream()
                                    .filter(uo -> uo.getUnitId() == m.unitId && uo.getOptionId() == m.optionId).findFirst().orElseThrow(() ->
                                            new IllegalArgumentException("No profile for unit id: %s and optionId: %s".formatted(m.unitId, m.optionId))))
                            .toList();
                }));
        Sectorial sectorialApiId = dataLoader.getAllSectorialIds().stream()
                .filter(s -> s.getId() == sectorialId)
                .findFirst().orElseThrow();
        return new ArmyList(sectorialApiId, fractionName, armyName, maxPoints, combatGroups);
    }

    private static CombatGroupMember getCombatGroupMemberFromCode(ByteBuffer data) {
        data.get(); // always starts with 0
        CombatGroupMember result = new CombatGroupMember(
                readVLI(data),
                readVLI(data),
                readVLI(data)
        );
        data.get(); // always ends with 0
        return result;
    }

    private static List<CombatGroupMember> getCombatGroupFromCode(ByteBuffer data) {
        int groupId = readVLI(data);
        data.get();// always 1
        data.get();// always 0
        int group_size = ArmyCodeLoader.readVLI(data);
        return IntStream.range(0, group_size).boxed()
                .map(i -> getCombatGroupMemberFromCode(data))
                .toList();
    }

    private record CombatGroupMember(
            int unitId,
            int groupId,
            int optionId) {
    }

}
